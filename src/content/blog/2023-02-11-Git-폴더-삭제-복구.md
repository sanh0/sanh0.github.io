---
author: Sanh0
pubDatetime: 2023-02-11
title: .git 폴더 삭제 후 복구
postSlug: git-folder-recover
featured: false
draft: false
tags:
    - git
description: 어젯밤, 아는 개발자가 실수로 회사의 개발 서버 레파지토리의 .git 폴더를 삭제했다면서 연락을 해봤다. 그 개발자는 당황한 기색이 역력해보였다. 다른 서버에서 .git 폴더를 복사해와야하나, 그래도 되는 걸까, 망설여하며 혼자 정신이 없었다. 다행히 때마침 내가 얼마 전에 git 관련한 책을 읽고 공부했었기 때문에 조금 도와줄 수 있었다.
---

(이 글은 Gui를 사용하지 못하는 터미널 환경이라고 가정하고 작성했다.)

어젯밤, 아는 개발자가 실수로 회사의 개발 서버 레파지토리의 .git 폴더를 삭제했다면서 연락을 해봤다. 그 개발자는 당황한 기색이 역력해보였다. 다른 서버에서 .git 폴더를 복사해와야하나, 그래도 되는 걸까, 망설여하며 혼자 정신이 없었다. 다행히 때마침 내가 얼마 전에 git 관련한 책을 읽고 공부했었기 때문에 조금 도와줄 수 있었다.

이때 다른 서버에서 git 폴더를 복사해오는 것도 방법일 수는 있겠지만, 레파지토리가 오래되고 브랜치가 많은데다가 Commit, Push, Merge 등이 활발히 이루어지는 레파지토리라면 아마도 .git 폴더에 내용물이 많을 것이다. 그것을 다운받고, 또 업로드 하며 물리적으로 복사하는 것은 시간이 든다. 또한 다른 레파지토리의 로컬 설정이 .git 폴더에 남아있어 충돌이 날 수도 있을 것 같았다.

그래서 물리적으로 다른 레포지토리의 .git 폴더를 옮겨오는 것 보다는, **fetch를 이용**해서 해결해보는게 좋아보였다.

이런 경우, 그 상태를 해결해보려고 이것저것 하느라 잘못된 .git 폴더가 한 번 더 생겨있을 수도 있다. 잘못 생성된 .git 폴더에서 작업하면 더 꼬일 수도 있으므로, 처음부터 다시 시작하는 게 좋다. 우선 .git 폴더를 삭제한다. 권한 등의 이유로 잘 지워지지 않는다면, `rm -rf` 명령어를 사용하여 깔끔하게 지워준다. (없으면 다음 단계로 넘어간다.)

```bash
rm -rf /~/.git/*	// .git 폴더 내부 파일 삭제
rm -rf /~/.git/	// .git 폴더 삭제
```

`/~/`에는 .git 폴더가 있는 디렉토리의 경로를 입력하면 된다.

이제 .git 폴더가 없는 완전한 태초의 상태가 되었다.

.git 폴더는 어떤 디렉토리를 단순한 폴더가 아닌 **Git 레파지토리**로 만들어주는 폴더이다. 이 폴더가 해당 디텍토리의 최상단에 위치해야 비로소 Git 레파지토리라고 부를 수 있게 된다. 이 폴더에는 버전 관리에 필요한 모든 내용이 들어있다. 각종 브랜치 정보와 히스토리, 그리고 원격 레파지토리의 정보 등이 있는 담겨있는 것이다. 이것을 지우면 해당 디렉토리는 Git 버전관리에 대한 모든 정보를 잃고, 더이상 Git 레파지토리가 아니게 된다.

지금은 .git 폴더가 없는 상태일 것이다. 코드가 담겨있는 그 디렉토리는 단순한 폴더일 뿐, Git 저장소라고 할 수 없다. Git 저장소가 아닌 만큼, 우리가 지금부터 하려는 fetch도 할 수 없다. 그렇기 때문에 먼저 git init을 사용해서 초기화를 해준다.

```bash
git init
// Initialized empty Git repository in [경로/.git]
```

초기화를 하면디렉토리에 .git 폴더가 생기고, 디렉토리는 Git 저장소가 된다. 하지만 아직 복구가 된 것은 아니다. 터미널에서 출력되었듯이 방금 만든 .git 폴더는 empty, 즉 아무런 정보도 담겨있지 않다. 그간 쌓아놓은 브랜치들이나 히스토리에 대한 정보는 커녕 리모트 저장소가 어디인지 조차 설정이 안되어 있다는 말이다.

그 정보들을 무사히 가져오려면, 일단 이 리모트 저장소에 레파지토리를 연결해줘야한다.

```bash
git remote add origin [원격 git 저장소 주소]
```

이렇게 연결되어야하는 원격 git 저장소 주소를 추가해준다.
그런 뒤에 아래처럼 `fetch`를 통해 원격 저장소가 가지고 있는 정보들을 가져올 수 있다.

```bash
git fetch --all
```

참고로 Git에서 `fetch`란 해당 저장소의 메타데이터들만 (브랜치 정보, 변경 내역 등) 가져오도록 하는 명령어이다. `pull`이나 `rebase`와는 다르게 **코드를 병합시키는 것이 아니다\***. 지금 우리가 하려는 건 코드 내용을 업데이트하는 게 아니라, 버전 관리 정보를 가져오는 것이다. `fetch`를 사용하면 그것들만 당겨올 수 있다.

위에서는 `--all` 옵션을 주었다. 이렇게하면 원격 저장소가 가진 모든 브랜치의 내역을 가져온다.
(특정 브랜치의 정보만 필요할 경우, 아래를 참고한다.)

```bash
git fetch	// 디폴트 브랜치를 Fetch
git fetch origint [브랜치]	// 특정 브랜치를 Fesch
```

잘 fetch 되었는지, 브랜치를 통해 확인한다.

```bash
git branch -a	// 원격+로컬 브랜치 확인
```

이제 원격에 있는 브랜치 정보들을 확인할 수 있다.
아래는 예시일 뿐이며, 레파지토리에 따라 다른 이름의 브랜치가 나올 것이다.

```bash
origin/master
origin/branch
...
```

그런데 모두 원격 저장소들이다. 로컬에는 브랜치가 없다. 현재 존재하는 코드들 역시 그 어떤 브랜치에도 속한 상태가 아니다. 로컬 저장소가 어떤 브랜치로 체크아웃 되어있는지까지 돌려놓는 것이 목적이므로, 마무리로 checkout을 해야한다.

하지만 현재 상태에서 `git checkout`을 하려면 오류메세지가 뜰 것이다.

```bash
error: The following untracked working tree files would be overwritten by checkout
```

그 이유는 로컬 저장소의 파일들이 git에 속한 파일로 취급되지 않기 때문이다. (untracked) 원격 레파지토리와 관련 있는 파일로 인식하는 게 아니라, 이름만 같은 다른 파일로 인식한다. 이를 해결하기 위해서는 체크아웃하기 전에, 로컬 레파지토리 최상단에서 아래와 같은 명령어를 입력한다.

```bash
git add .
```

현재 폴더 내부의 모든 파일을 git으로 관리한다고 선언하는 명령어이다. 이를 통해 모든 파일을 git이 추적하도록 만들 수 있다. 이 이후에 `git branch -a` 을 통해 확인한 브랜치 중, 원하는 브랜치로 checkout을 해주면 된다.

```bash
git checkout [브랜치명]
```
